	 //0,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
let map =[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //00
/*--1---*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //01
/*--2---*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //02
/*--3---*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,25, 0, 0, 0, 0,25, 0, 0, 0, 0,25, 0, 0, 0, 0,25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //03
/*--4---*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //04
/*--5---*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,27, 0, 0, 0,  //05
/*--6---*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //06
/*--7---*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //07 
/*--8---*/ 0, 0, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0,  //08
/*--9---*/ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,25, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0,25, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];//09

let blocks = [];

// --- tileset geometry ---
const original_tileSize = 20;  // your sheet is 16×16 cells

// these will be filled after the image loads
let tilesetCols = 0;
let tilesetRows = 0;

const tileSize = 54;            // world size
const columns = 100;            // level width in tiles
const rows = 20;                // level height in tiles


// Tile categories (adjust if you change your map semantics)
const SOLID_TILES = new Set([1, 2, 25, 16, 6, 27]); // collide with the player
const HAZARD_TILES = new Set([6]);                  // hurts/respawn
const KEY_TILE_INDEX  = 260;                        // your current key location (by index)
const DOOR_TILE_INDEX = 596;                        // your current door location (by index)

let dino, block, sprite;

function preload() {
  // use your new image
  block = loadImage('src/assets/tile_sheet.png', (img) => {
    tilesetCols = Math.floor(img.width  / original_tileSize);
    tilesetRows = Math.floor(img.height / original_tileSize)+1;

    // sanity check (optional)
    if (tilesetCols * original_tileSize !== img.width ||
        tilesetRows * original_tileSize !== img.height) {
      console.warn('Tileset width/height are not multiples of 16px. Crop or fix source.');
    }
  });

  sprite = loadImage('src/assets/player.png');
}


function setup() {
  createCanvas(windowWidth, tileSize * rows);

  dino = new Dino();

  // Build blocks array only where we need solid collisions
  for (let i = 0; i < map.length; i++) {
    if (SOLID_TILES.has(map[i])) {
      const x = (i % columns) * tileSize;
      const y = floor(i / columns) * tileSize;
      blocks[i] = new Block(x, y);
    }
  }
}

function draw() {
  background(99, 173, 255);

  // --- Basic camera following on X (keeps player at ~1/3 screen) ---
  const cameraX = max(0, dino.x - width / 3);

  // WORLD (translated)
  push();
  translate(-cameraX, 0);

  //drawMap_fromImage();
  //dino.show();
  // DEV: render the picker grid in world space
  // TEMP (inside the push() world block):
	image(block, 0, 0); // draws the whole tileset at top-left
	drawPickerOverlay();
	

  pop();

  // UI / HUD (no camera transform)
  fill(0);
  noStroke();
  textSize(15);
  textAlign(LEFT, TOP);
  text("LIFES: " + dino.lifes, 10, 10);
  text("Key: "  + dino.key,   10, 30);

  // Physics / Inputs / Collisions
  dino.update();
  dino.move();

}

// Draw only tiles that are present (skip zeros)
function drawMap_fromImage() {
  for (let i = 0; i < map.length; i++) {
    const value = map[i];
    if (!value) continue;

    const v  = value - 1; // 1-based IDs
    const sx = (v % tilesetCols) * original_tileSize;
    const sy = Math.floor(v / tilesetCols) * original_tileSize;
    const dx = (i % columns) * tileSize;
    const dy = Math.floor(i / columns) * tileSize;

    image(block, dx, dy, tileSize, tileSize, sx, sy, original_tileSize, original_tileSize);
  }
}


function windowResized() {
  resizeCanvas(windowWidth, tileSize * rows);
}

// Collect only tiles near the player's AABB for collision checks
function tilesNearPlayer(px, py, size) {
  const minCol = max(0, floor((px - size) / tileSize));
  const maxCol = min(columns - 1, floor((px + size) / tileSize));
  const minRow = max(0, floor((py - size) / tileSize));
  const maxRow = min(rows - 1, floor((py + size) / tileSize));
  const list = [];
  for (let r = minRow; r <= maxRow; r++) {
    for (let c = minCol; c <= maxCol; c++) {
      const idx = r * columns + c;
      if (blocks[idx]) list.push(idx);
    }
  }
  return list;
}

// Simple AABB
function AABB(x1, y1, w1, h1, x2, y2, w2, h2) {
  return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
}

function keyPressed() {
  // Jump buffer: Space / Z / W / Up
  if (keyCode === 32 || keyCode === 90 || keyCode === 87 || keyCode === UP_ARROW) {
    dino.jumpBuffered = dino.jumpBufferMax;
  }
}

// Basic block for collisions
function Block(x, y) {
  this.x = x;
  this.y = y;
  this.w = tileSize;
}

// --- DEV: tile ID helper ---
let showPicker = false;

function keyTyped() {
  if (key === 'i' || key === 'I') showPicker = !showPicker; // toggle overlay
}

// Convert (col,row) on tileset -> 1-based frame ID used in map[]
function tileId(c, r) {
  return r * tilesetCols + c + 1;
}

// Click anywhere near the top-left of the world where the tileset is visible
function mousePressed() {
  if (!showPicker) return;
  // Where did we click in world-space?
  // (camera translate is applied in draw(), so compensate)
  const cameraX = Math.max(0, dino.x - width / 3);
  const worldX = mouseX + cameraX;
  const worldY = mouseY;

  // If you draw the tileset at (0,0) during inspection,
  // clicking a cell gives you its (col,row):
  const c = Math.floor(worldX / original_tileSize);
  const r = Math.floor(worldY / original_tileSize);
  if (c >= 0 && c < tilesetCols && r >= 0 && r < tilesetRows) {
    const id = tileId(c, r);
    console.log(`tileset cell → col:${c}, row:${r}, id:${id}`);
  }
}

function drawPickerOverlay() {
  if (!showPicker) return;
  push();
  noFill();
  stroke(0, 150);
  // draw a 16px grid over the top-left 528x448 area
  for (let x = 0; x <= tilesetCols * original_tileSize; x += original_tileSize) {
    line(x, 0, x, tilesetRows * original_tileSize);
  }
  for (let y = 0; y <= tilesetRows * original_tileSize; y += original_tileSize) {
    line(0, y, tilesetCols * original_tileSize, y);
  }
  pop();

  // Label
  push();
  fill(0, 180);
  noStroke();
  rect(575, 545, 250, 40);
  fill(255);
  textSize(12);
  textAlign(LEFT, TOP);
  text('Tile Picker ON: press [I] to toggle.\nClick a cell → see col,row,id in console', 580, 550);
  pop();
}
